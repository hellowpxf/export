十一、   TCP协议是七层网络协议中的传输层协议，负责数据的可靠传输
在简历TCP连接TCP的三次握手和四次挥手
             是，需要通过三次握手来建立，过程是
1、客户端向服务端发送一个SYN
2、服务端收到SYN后，给客服端发送一个SYN_ACK
3、客户端接收到SYN_ACK后，再给服务端发送一个ACK
在断开连接时，需要通过四次挥手来断开，过程是：
1、客户端向服务端发送FIN
2、服务端收到FIN后，向客户端发送ACK,表示收到了断开连接的请求，客户端可以不发数据了，不过服务端这边可能还有数据正在处理
3、服务端处理完所有数据后，向客户端发送NIF,表示服务端现在可以断开连接
4、客服端收到FIN，向服务端发送ACK,表示客户端也会断开连接。




十二、在java的异常处理机制中，什么时候应该抛出异常，什么时候应该捕捉异常

十三、java中有哪些类加载器
JVM中存在是哪个默认的类加载器
1、BootstrapClassLoader （加载的是lib下的jar包和class文件）
2、ExtClassLoader（加载的是lib/ext下的jar包和文件）
3、AppClassLoader（负责加载classpath下的文件）
AppClassLoader的父类是ExtClassLoader，ExtClassLoader的父类是BootstrapClassLoader

JVM在加载一个类时，会调用AppClassLoader的loadClass 方法来加载这个类，不过在这个方法中，会先使用ExtClassLoader的loadClass方法
来加载类，同样ExtClassLoader的loadClass方法中会先使用BootstrapClassLoader来加载，如果BootstrapClassLoader加载到了就直接成功
如果BootstrapClassLoader没有加载到，那个ExtClassLoader就会自己尝试加载该类，如果没有加载到，就会又由AppClassLoader加载这个类。

JVM 有哪些垃圾回收算法？
1、标记清除算法：
2、复制算法：
3、标记压缩算法：

JVM有哪些参数
1、标注指令 -开头，这些都是HostSpot支持的参数，可以用java-help 打印出来
2、非标准指令 -x开头指令通常是跟特定的HotSot 版本对应可以用java-X打印出来。
3、不稳定参数： -XX开头，这一类参数是跟特定HotSpot版本对应的，并且变化非常大。


JVM中那些是线程共享区
堆区和方法区是所有线程共享的，本地方法栈，虚拟机栈程序计数器是每个个线程独有的。

你们项目如何排查JVM问题
对于还在正常运行的系统：
1、可以使用jmap 来看着JVM各个区域的使用情况
2、还可以通过jstack来查看线程的运行情况，比如那些线程阻塞，是否出现死锁。
3、还可以通过jstack 命令来查看垃圾回收的情况，特别是fullgc ,如果发现是fullgc比较频繁，那么就得进行调优。
4、通过各个命令的结果，或者jvisualvm等工具进行分析
5、首先，初步猜测频繁发送fullgc的原因，如果频繁发生fullgc但是一直没有出现内存溢出，那么标识fullgc实际上回收了很多对象，所以这些对象最好能在younggcc被回收调


对线程安全的理解
线程安全指的是，我们写某段代码，在多个线程同时执行这段代码时，不会产生混乱，依然能够得到正常结果，比如i++ i初始值为零，如果两个线程都执行了
代码，安全的线程输出的结果应该是1,2 如果两个线程都输出1则表示线程不安全的。线程安全是指一段代码在多个线程同时执行的情况了，能否得到正确的结果。

什么是字节码？字节码的好处？
javac java 源文件编译成为字节码文件 *.class 可以做到一次编译处处运行。


一个对象从加载到JVM,再到被GC清除，都经历了什么过程
1、首先把字节码文件加载到方法区。
2、然后根据类信息在堆区创建对象。
3、对象首先会分配在堆区中年轻代的eden区，对象如果存活，就会进入suvivor区。后续的每次Minor GC中，如果对象一直存活，就会在Suvivor区来回拷贝，
每移动一次年龄加一
4、当年龄超过15后，对象依然存活，就会进入老年代。
5、如果经过full gc, 被标记为垃圾对象，那么就会被GC线程清理掉

怎么确定一个对象到底是不是垃圾对象？
1、引用计数算法：这种方式是给堆内存当中的每个对象记录一个引用数。引用数为0就认为是来及。这是jdk早期的使用方式，引用计数无法解决循环引用的问题。
2、可达性分析算法那：这种方式是在内存中，从根对象向下一直找引用，找到的对象就不是垃圾，没有找到的就是垃圾对象。

HashMap的扩容机制原理
1、7版本
1、生成新数组
2、遍历老数组中的每个位置上的链表的每个元素
3、取每个元素的key,并基于新数组长度，计算出每个元素在新数组中的下标
4、将元素添加到新数组中去
5、所有元素转移完成紫狐，将新数组赋值给HashMap对象的table属性

1、8版本
1、先生成新数组
2、遍历老数组中每个位子上的链表或者红黑树
3、如果是链表，则先遍历链表中的每个元素重新计算下标，并添加到数组中午。
4、如果是红黑树，则新遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置



缓存穿透、缓存击穿、缓存雪崩分别是是什么
    缓存中存放的大多都是热点数据，目的就是让请求可以直接从缓存中获得到数据，而不用访问mysql
    1、缓存雪崩：如果缓存中某一时刻大批热点数据同时过期，那么就可能导致大量请求直接访问Mysql了，解决办法就是在过期期间加上一点随机值，另外
    如果搭建一个高可用的Redis集群也是防止缓存雪崩的有效手段
    2、缓存击穿：和缓存雪崩类似，缓存雪崩是大批热点数据失效，而缓存击穿是指某一个热点key突然失效，也导致了大量请求直接访问Mysql。数据库
    这就是缓存击穿，解决方案就是考虑这个热点key不设置过期时间。
    2、缓存穿透：假如某一时刻访问Redis的大量key中不存在，（比如黑客故意伪造一些乱起八糟的key）那么也会给数据库造成压力，这就是缓存穿透，解决方案就是使用
    布隆过滤器，它的作用是如果它认为一个Key不存在，那么这个key肯定不存在，所以可以在缓存之前加一层布隆过滤器来拦截不存在的key.

什么是RDB和AOF
    RDB Redis DataBase ，在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，
    用二进制压缩存储。

    优点：
    1、整个Redis数据库只包含一个文件Dump.rdb,方便持久化。
    2、容灾性好，方便备份。
    3、性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以io最大化。使用单独子进程进行持久化，主进程不会进行任务io操作，保证了redis
    的高性能。
    4、相对于数据集大时，比AOF的启动效率更高。

    缺点：
    1、数据安全性低。RDB是 间隔一段时间进行持久化，如果持久化自检Redis发生故障，会发生数据丢失。所以这种方式更是合适数据不严谨的时候。
    2、由于RDB是通过子进程来协助完成数据持久化工作的，因此，如果当数据集比较大时，可能会导致整个服务器停止服务几百毫秒，甚至是一秒钟。

    AOF Append Only File ,以日志的形式记录服务器所处的每一个写，删除操作，查询操作不会记录，以文本的方式记录，可以打卡文件看到详细的操作记录

    优点：
    1、数据安全，Redi提供了三种同步操作，即每秒同步，每修改同步和不同步，事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦出现系统
    宕机现象，那么这一秒内修改的数据也会丢失，每秒修改同步，我们可以将其视为持久化，即每次发生的数据变化都会被立即记录到磁盘中。
    2、通过append模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，通过redis-check-aof 解决数据一致问题。
    3、AOF 机制的rewrite模式，定期对AOF文件进行重写，以达到压缩的目的。

    缺点：
    1、AOF文件比RDB文件大，且恢复速度慢。
    2、数据集大的时候，比rdb 启动效率低。
    3、效率没有RDB高

Springboot 是如何启动Tomcat的

    1、首先，Springboot 在启动时会创建一个Spring容器
    2、在创建Spring容器过程中，会利用@ConditionNalonClass 技术来判断当前Classpath 中是否存在Tomcat 依赖，如果存在则
    会生成一个启动Tomcat 的bean;
    3、Spring容器创建完之后，就会获取启动Tomcat的bean,并创建Tomcat对象，并绑定端口等，然后启动Tomcat

Springboot中常用的注解及其底层实现
    1、@SpringbootApplication注解：这个注解标识了一个Springboot工程，它实际上是另外三个注解的组合，这三个注解是：
    b、@SpringbootConfiguration 向Spring容器中导入了一个Selector ，用来加载，classpath下SpringFactory 中所定义的自动配置类，将这些
    自动加载为配置bean
    c、@ComponentScan:标识扫码路径，因为默认是没有配置实际扫码路径，所以Springboot扫码的路径是启动类所在当前目录
   2.@Bean注解： 用来定义Bean ,类似于XML中的《bean》标签，spring在启动时，会对加了Bean注解的方法进行解析，将方法的名字作为beanname ,并通过执行这个方法
   得到Bean对象
   3.@Controller,@Service 、@ResponseBody、@Autowired


Eureka包含两个组件:Eureka Server和Eureka Client

Eureka Server提供服务注册服务

各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。

EurekaClient通过注册中心进行访问

它是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒)


Redis 数据类型
String、List、Set、ZSet、Hash


二叉树遍历
    先序（头、左、右）
    中序（左、头、右）
    后序（左、右、头）


aop使用场景，参数加密解密、日志记录、性能

https加密原理概述
1、客户端和服务端简历ssl握手，客户端通过CA证书来确认服务端的身份；
2、相互传递三个随机数，之后公国这随机数来生成一个密钥；
3、相互确认密钥，然后握手结束；
4、数据通讯考试，同使用同一个对话密钥来加密解密

接口幂等性
1、数据库唯一主键分布式id（插入）
2、数据库乐观锁
3、防重 Token 令牌（连续点击或者调用方的超时重试等情况）

什么是 IoC
    IoC （Inversion of control ）控制反转/反转控制。它是一种思想不是一个技术实现。描述的是：Java 开发领域对象的创建以及管理的问题。
    IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。

mybatis 中使用的设计模式
创建型模式
  工厂模式 SqlSessionFactory、MapperProxyFactory、DataSourceFactory
    场景介绍：SqlSessionFactory 是获取会话的工厂，每次使用MyBatis 操作数据库时， 都会开启一个新的会话。在会话工厂的实现中，
    SqlSessionFactory 负责获取数据源环境配置信息、构建事务工厂和创建操作SQL 的执行器，最终返回会话实现类。

  单例模式 ：是一种创建型模式，能够保证一个类只有一个实例，并且提供一个访问该实例的全局节点。
    Configuration、LogFactory
    场景介绍：Configuration 是一个大单例，贯穿整个会话周期，所有的配置对象（如映射、缓存、入参、出参、拦截器、注册机和对象工厂等）
    都在Configuration 配置项中初始化， 并且随着SqlSessionFactoryBuilder 构建阶段完成实例化操作。

结构型模式
  适配器模式：是一种结构型模式，能使接口不兼容的对象也可以相互合作。

  场景介绍：正是因为有太多的日志框架，包括Log4j、Log4j2 和Slf4J 等，
  而这些日志框架的使用接口又各有差异，为了统一这些日志框架的接口，MyBatis 定义了一套统一的接

  代理模式：是一种结构型模式，能够提供对象的替代品或占位符。代理控制元对象的访问，并且允许在将请求提交给对象前进行一些处理。
  场景介绍：没有代理模式就不存在各类框架。就像MyBatis 中的MapperProxy 实现类， 代理工厂实现的功能就是完成DAO 接口的具体实现类的方法，
  配置的任何一个DAO 接口调用的CRUD 方法，都会被MapperProxy 接管，调用到方法执行器等，并返回最终的数据库执行结果。

行为型模式
模板模式



hystrix 处理分布式系统延迟和容错的开源库，保证一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。
 服务降级 fallback （返回一个友好提示）
    导致原因：程序运行异常、超时、服务熔断触发服务降级、线程池信号量打满
 服务熔断 break  （保险丝：到达最大访问量后直接拒绝访问）
 服务限流  排队执行



w









